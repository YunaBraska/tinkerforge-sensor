package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.type.ValueType;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.SEPARATOR;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.toHumanReadable;
import static java.util.Arrays.asList;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorEnumValueType {

    public static JavaFile generate() {
        final String packageName = ValueType.class.getPackage().getName();
        final String className = ValueType.class.getSimpleName();
        final ClassName thisClass = ClassName.get(packageName, className);
        final String paramName = "parent";
        final String paramNameVT = firstLetterLow(className);
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";

        final MethodSpec method_isTypeOf = methodIsTypeOf(thisClass, paramNameVT);
        final MethodSpec method_containsTypeOf = methodContainsTypeOf(thisClass, paramName, paramNameVT);
        final MethodSpec method_constructor = methodConstructor(thisClass, paramName);


        //CREATE ENUM VALUES AND METHODS
        final TypeSpec.Builder resultClass = TypeSpec.enumBuilder(className);
        for (ValueType valueType : ValueType.values()) {
            final String typeName = valueType.toString();
            resultClass.addEnumConstant(typeName, TypeSpec.anonymousClassBuilder("$L", valueType.parent).build());

            final MethodSpec isType = methodInnerIsTypeOf(valueType, typeName);
            final MethodSpec containsType = methodInnerContainsType(valueType, typeName);

            resultClass.addMethods(asList(isType, containsType));
        }

        resultClass.addModifiers(PUBLIC)
                .addJavadoc("$N" + SEPARATOR + " You can add new enumTypes without harm" + SEPARATOR, autogenerated)
                .addField(thisClass, paramName, PUBLIC, FINAL)
//                .addField(Long.class, "maxValue", PUBLIC, FINAL)
                .addMethods(asList(method_constructor, method_isTypeOf, method_containsTypeOf));

        return JavaFile.builder(ValueType.class.getPackage().getName(), resultClass.build()).build();
    }

    private static MethodSpec methodInnerContainsType(final ValueType valueType, final String typeName) {
        return MethodSpec.methodBuilder("contains" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addStatement("return this.is($N) || (this.parent != null && this.parent.contains($N))", typeName, typeName)
                .build();
    }

    private static MethodSpec methodConstructor(final ClassName thisClass, final String paramName) {
        return MethodSpec.constructorBuilder()
                .addParameter(thisClass, paramName, FINAL)
//                .addParameter(Long.class, "maxValue", FINAL)
                .addStatement("this.$N = $N", paramName, paramName)
//                .addStatement("this.maxValue = maxValue")
                .build();
    }

    private static MethodSpec method_getThreshold() {
        return MethodSpec.methodBuilder("getThreshold")
                .addModifiers(PUBLIC)
                .addParameter(Long.class, "maxValue", FINAL)
                .addCode("if (this.maxValue == null || maxValue == null) {" + SEPARATOR + "  return 1;" + SEPARATOR + "}"  + SEPARATOR)
                .addStatement("int threshold = 1")
                .addStatement("final int maxLength = (int) (Math.log10(this.maxValue) + 1)")
                .addStatement("final int currentLength = (int) (Math.log10(maxValue) + 1)")
                .addCode("if (currentLength > maxLength || maxValue > this.maxValue) {" + SEPARATOR)
                .addCode("  throw new UnsupportedOperationException(format(\"Please update the maxValue [%s] to [%s] for [%s]\", this.maxValue, maxValue, this.name()));")
                .addCode("}"  + SEPARATOR)
                .addCode("for (int i = currentLength; i < maxLength; i++) {" + SEPARATOR)
                .addCode("  threshold = threshold * 10;")
                .addCode("}" + SEPARATOR)
                .addStatement("return threshold")
                .build();
    }

    private static MethodSpec methodContainsTypeOf(final ClassName thisClass, final String paramName, final String paramNameVT) {
        return MethodSpec.methodBuilder("contains")
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addParameter(thisClass, paramNameVT, FINAL)
                .addStatement("return this.is($N) || (this.$N != null && this.$N.contains($N))", paramNameVT, paramName, paramName, paramNameVT)
                .build();
    }

    private static MethodSpec methodIsTypeOf(final ClassName thisClass, final String paramNameVT) {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addParameter(thisClass, paramNameVT, FINAL)
                .addStatement("return this == $N", paramNameVT)
                .build();
    }

    private static MethodSpec methodInnerIsTypeOf(final ValueType valueType, final String typeName) {
        return MethodSpec.methodBuilder("is" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addStatement("return this == $N", typeName)
                .build();
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }
}