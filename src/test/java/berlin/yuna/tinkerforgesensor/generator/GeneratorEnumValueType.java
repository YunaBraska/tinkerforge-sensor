package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.type.ValueType;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Collectors;

import static java.lang.Character.toUpperCase;
import static java.lang.String.format;
import static java.util.Arrays.asList;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorEnumValueType {

    public static void generate() throws IOException {
        String packageName = ValueType.class.getPackage().getName();
        String className = ValueType.class.getSimpleName();
        ClassName thisClass = ClassName.get(packageName, className);
        String paramName = "parent";
        String paramNameVT = firstLetterLow(className);
        StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";

        MethodSpec method_isTypeOf = methodIsTypeOf(thisClass, paramNameVT);
        MethodSpec method_containsTypeOf = methodContainsTypeOf(thisClass, paramName, paramNameVT);
        MethodSpec method_constructor = methodConstructor(thisClass, paramName);


        //CREATE ENUM VALUES AND METHODS
        TypeSpec.Builder valueTypeClass = TypeSpec.enumBuilder(className);
        for (ValueType valueType : ValueType.values()) {
            String typeName = valueType.toString();
            valueTypeClass.addEnumConstant(typeName, TypeSpec.anonymousClassBuilder("$L", valueType.parent).build());

            MethodSpec isType = methodInnerIsTypeOf(valueType, typeName);
            MethodSpec containsType = methodInnerContainsType(valueType, typeName);

            valueTypeClass.addMethods(asList(isType, containsType));
        }

        valueTypeClass.addModifiers(PUBLIC)
                .addJavadoc("$N\n You can add new enumTypes without harm\n", autogenerated)
                .addField(thisClass, paramName, PUBLIC, FINAL)
                .addMethods(asList(method_constructor, method_isTypeOf, method_containsTypeOf));

        //Path sourceFile = getSourceFile(packageName, className);
        JavaFile.builder(packageName, valueTypeClass.build()).build().writeTo(new File("src/main/java"));
    }

    private static MethodSpec methodInnerContainsType(ValueType valueType, String typeName) {
        return MethodSpec.methodBuilder("contains" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addStatement("return this.is($N) || (this.parent != null && this.parent.contains($N))", typeName, typeName)
                .build();
    }

    private static MethodSpec methodConstructor(ClassName thisClass, String paramName) {
        return MethodSpec.constructorBuilder()
                .addParameter(thisClass, paramName)
                .addStatement("this.$N = $N", paramName, paramName)
                .build();
    }

    private static MethodSpec methodContainsTypeOf(ClassName thisClass, String paramName, String paramNameVT) {
        return MethodSpec.methodBuilder("contains")
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addParameter(thisClass, paramNameVT)
                .addStatement("return this.is($N) || (this.$N != null && this.$N.contains($N))", paramNameVT, paramName, paramName, paramNameVT)
                .build();
    }

    private static MethodSpec methodIsTypeOf(ClassName thisClass, String paramNameVT) {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addParameter(thisClass, paramNameVT)
                .addStatement("return this == $N", paramNameVT)
                .build();
    }

    private static MethodSpec methodInnerIsTypeOf(ValueType valueType, String typeName) {
        return MethodSpec.methodBuilder("is" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(boolean.class)
                .addStatement("return this == $N", typeName)
                .build();
    }

    private Path getSourceFile(String packageName, String className) throws IOException {
        return Files.find(Paths.get(System.getProperty("user.dir")),
                Integer.MAX_VALUE, (filePath, fileAttr) -> fileAttr.isRegularFile())
                .filter(path -> path.toString().endsWith(format("%s/%s.java", packageName.replace(".", "/"), className))).collect(Collectors.toList()).get(0);
    }

    private static String toHumanReadable(final Enum<?> anEnum, boolean startUpperCase) {
        char[] chars = anEnum.toString().toLowerCase().toCharArray();
        if (startUpperCase) {
            chars[0] = toUpperCase(chars[0]);
        }
        for (int i = 1; i < chars.length; i++) {
            char prev = chars[i - 1];
            if (prev == '_') {
                chars[i] = toUpperCase(chars[i]);
            }
        }
        return new String(chars).replace("_", "");
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }
}