package berlin.yuna.tinkerforgesensor.generator;

import berlin.yuna.tinkerforgesensor.model.JFile;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.LINE_SEPARATOR;
import static berlin.yuna.tinkerforgesensor.model.JFile.DIR_README;
import static berlin.yuna.tinkerforgesensor.model.JFile.JAVA_EXTENSION;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

public class GeneratorReadmeDoc {

    //https://github.com/YunaBraska/tinkerforge-sensor/blob/master/readmeDoc/README.md
    //https://github.com/YunaBraska/tinkerforge-sensor/blob/master/readmeDoc/readmeDoc/berlin/yuna/tinkerforgesensor/model/sensor/bricklet/README.md
    public static void generate(final List<JFile> jFileList) {
        try {
            deleteDir(DIR_README.toPath());
            final List<JFile> jFiles = new ArrayList<>(jFileList);
            final List<JFile> jFilesCements = jFiles.stream().filter(JFile::hasComments).collect(toList());
            final Set<String> packageGroups = jFilesCements.stream().map(file -> file.getClazz().getPackage().getName()).collect(toSet());
            final StringBuilder navigation = createNavigation(jFilesCements, packageGroups);

            createIndex(navigation, packageGroups, jFilesCements);
            for (JFile jFile : jFilesCements) {
                GeneratorReadmeDocHelper.generate(navigation, packageGroups, jFiles, jFile);
            }
            System.out.println(jFilesCements);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private static void deleteDir(final Path path) throws IOException {
        if(Files.exists(path)) {
            Files.walk(path)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        }
    }

    private static void createIndex(final StringBuilder navigation, final Set<String> packageGroups, final List<JFile> jFiles) {
        createRootIndex(navigation);
        for (String packageGroup : packageGroups) {
            final StringBuilder result = new StringBuilder();
            final List<JFile> packageFiles = jFiles.stream().filter(file -> file.getClazz().getPackage().getName().equals(packageGroup)).collect(toList());

            result.append(LINE_SEPARATOR);
            result.append("## ");
            result.append(packageGroup);
            result.append(LINE_SEPARATOR);
            result.append(navigation);
            result.append("---").append(LINE_SEPARATOR);

            for (JFile jFile : packageFiles) {
                result.append("* [").append(jFile.getClazz().getSimpleName()).append("]");
                result.append("(").append(jFile.getReadmeFileUrl().toString()).append(")");

                result.append(" ([source]");
                result.append("(").append(jFile.getRelativeMavenUrl().toString()).append("))");
                result.append(LINE_SEPARATOR);
            }
            result.append("---").append(LINE_SEPARATOR);

            final File targetFile = new File(JFile.DIR_PROJECT, packageFiles.get(0).getReadmePackagePath().toString());
            try {
                if (!targetFile.exists()) {
                    targetFile.getParentFile().mkdirs();
                    System.out.println("Created [" + targetFile + "]");
                    Files.write(targetFile.toPath(), result.toString().getBytes());
                }
            } catch (IOException e) {
                throw new RuntimeException("failed to write index file for [" + targetFile + "]", e);
            }
        }
    }

    private static void createRootIndex(final StringBuilder navigation) {
        final File targetFile = new File(DIR_README, "README.md");
        final StringBuilder result = new StringBuilder();
        result.append(LINE_SEPARATOR);
        result.append("## ReadmeDoc");
        result.append(LINE_SEPARATOR);
        result.append("###### autogenerated by ");
        result.append(GeneratorReadmeDoc.class.getSimpleName());
        result.append(LINE_SEPARATOR);
        result.append(navigation);

        try {
            if (!targetFile.exists() && DIR_README.mkdirs()) {
                System.out.println("Created [" + targetFile + "]");
                Files.write(targetFile.toPath(), result.toString().getBytes());
            }
        } catch (IOException e) {
            throw new RuntimeException("failed to write index file for [" + targetFile + "]", e);
        }
    }

    private static StringBuilder createNavigation(final List<JFile> jFiles, final Set<String> packageGroups) {
        final StringBuilder result = new StringBuilder();
        result.append("* ");
        for (String packageGroup : packageGroups) {
            final JFile jFile = jFiles.stream().filter(file -> file.getClazz().getPackage().getName().equals(packageGroup)).collect(toList()).get(0);
            result.append("[").append(jFile.getPath().getParent().getFileName().toString().replace(JAVA_EXTENSION, "")).append("]");
            result.append("(").append(jFile.getReadmePackageUrl().toString()).append(") Â· ");
        }
        result.append(LINE_SEPARATOR);
        return result;
    }
}