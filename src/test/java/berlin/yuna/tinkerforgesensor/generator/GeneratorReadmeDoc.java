package berlin.yuna.tinkerforgesensor.generator;

import berlin.yuna.tinkerforgesensor.model.JFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getClassVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.LINE_SEPARATOR;
import static berlin.yuna.tinkerforgesensor.model.JFile.DIR_PROJECT;
import static berlin.yuna.tinkerforgesensor.model.JFile.DIR_README;
import static berlin.yuna.tinkerforgesensor.model.JFile.JAVA_EXTENSION;
import static java.util.Comparator.reverseOrder;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

public class GeneratorReadmeDoc {

    public static void generate(final List<JFile> jFileList) {
        try {
            deleteDir(DIR_README.toPath());
            final List<JFile> jFiles = new ArrayList<>(jFileList);
            final List<JFile> jFilesComments = jFiles.stream().filter(JFile::hasComments).collect(toList());
            final Set<String> packageGroups = jFilesComments.stream().map(file -> file.getClazz().getPackage().getName()).collect(toSet());
            final StringBuilder navigation = createNavigation(jFilesComments, packageGroups);

            createIndex(navigation, packageGroups, jFilesComments);

            while (!jFilesComments.isEmpty()) {
                final List<JFile> classVersions = getClassVersions(jFilesComments.listIterator().next(), jFiles);
                GeneratorReadmeDocHelper.generate(navigation, jFiles, classVersions.get(0));

                //Generate readme.md only for new versions
                for (JFile classVersion : classVersions) {
                    jFilesComments.remove(classVersion);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private static void deleteDir(final Path path) throws IOException {
        if (Files.exists(path)) {
            Files.walk(path)
                    .sorted(reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete);
        }
    }

    private static void createIndex(final StringBuilder navigation, final Set<String> packageGroups, final List<JFile> jFiles) {
        createRootIndex(navigation);
        for (String packageGroup : packageGroups) {
            final StringBuilder result = new StringBuilder();
            final List<JFile> packageFiles = jFiles.stream().filter(file -> file.getClazz().getPackage().getName().equals(packageGroup)).collect(toList());
            final File packageGroupPath = packageFiles.get(0).getReadmePackagePath();

            result.append(LINE_SEPARATOR);
            result.append("## ");
            result.append(packageGroup);
            result.append(LINE_SEPARATOR);
            result.append(navigation);
            result.append("---").append(LINE_SEPARATOR);

            while (!packageFiles.isEmpty()) {
                final List<JFile> classVersions = getClassVersions(packageFiles.listIterator().next(), jFiles);
                final JFile jFile = classVersions.get(0);

                result.append("* [").append(jFile.getBasicName()).append("]");
                result.append("(").append(jFile.getReadmeFileUrl().toString()).append(")");

                result.append(" ([source]");
                result.append("(").append(jFile.getRelativeMavenUrl().toString()).append("))");
                result.append(LINE_SEPARATOR);

                //Generate readme.md only for new versions
                for (JFile classVersion : classVersions) {
                    packageFiles.remove(classVersion);
                }
            }

            result.append("---").append(LINE_SEPARATOR);

            final File targetFile = new File(DIR_PROJECT, packageGroupPath.toString());
            try {
                if (!targetFile.exists()) {
                    targetFile.getParentFile().mkdirs();
                    System.out.println("Created [" + targetFile + "]");
                    Files.write(targetFile.toPath(), result.toString().getBytes());
                }
            } catch (IOException e) {
                throw new RuntimeException("failed to write index file for [" + targetFile + "]", e);
            }
        }
    }

    private static void createRootIndex(final StringBuilder navigation) {
        final File targetFile = new File(DIR_README, "README.md");
        final StringBuilder result = new StringBuilder();
        result.append(LINE_SEPARATOR);
        result.append("## ReadmeDoc");
        result.append(LINE_SEPARATOR);
        result.append("###### autogenerated by ");
        result.append(GeneratorReadmeDoc.class.getSimpleName());
        result.append(LINE_SEPARATOR);
        result.append(navigation);

        try {
            if (!targetFile.exists() && DIR_README.mkdirs()) {
                System.out.println("Created [" + targetFile + "]");
                Files.write(targetFile.toPath(), result.toString().getBytes());
            }
        } catch (IOException e) {
            throw new RuntimeException("failed to write index file for [" + targetFile + "]", e);
        }
    }

    private static StringBuilder createNavigation(final List<JFile> jFiles, final Set<String> packageGroups) {
        final StringBuilder result = new StringBuilder();
        result.append("* ");
        for (String packageGroup : packageGroups) {
            final JFile jFile = jFiles.stream().filter(file -> file.getClazz().getPackage().getName().equals(packageGroup)).collect(toList()).get(0);
            result.append("[").append(jFile.getPath().getParent().getFileName().toString().replace(JAVA_EXTENSION, "")).append("]");
            result.append("(").append(jFile.getReadmePackageUrl().toString()).append(") Â· ");
        }
        result.append(LINE_SEPARATOR);
        return result;
    }
}