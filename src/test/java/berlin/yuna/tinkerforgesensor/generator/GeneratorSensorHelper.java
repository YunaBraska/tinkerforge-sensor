package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.sensor.bricklet.Sensor;
import berlin.yuna.tinkerforgesensor.util.SensorTypeHelper;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.tinkerforge.Device;

import java.util.List;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getBasicSensorName;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getSensorVersions;
import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorSensorHelper {

    public static JavaFile generate(final List<Class<? extends Sensor>> sensorList) {
        final String deviceLowName = firstLetterLow(Device.class.getSimpleName());
        final TypeName classOfAnyDevice = ParameterizedTypeName.get(ClassName.get(Class.class), subtypeOf(Device.class));
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java",
                                                                                    "") + ":" + trace.getMethodName() + "]";

        //CREATE CLASS
        final TypeSpec.Builder sensorHelper = TypeSpec.classBuilder(SensorTypeHelper.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addJavadoc("$N\nRegistration of {@link $T} and the Wrapper\n{@link $T}\n",
                            autogenerated,
                            Device.class,
                            Sensor.class);

        final FieldSpec sensorField = FieldSpec.builder(Sensor.class, "sensor", PUBLIC, FINAL).build();
        final MethodSpec constructor = constructor();

        //CREATE METHODS
        while (!sensorList.isEmpty()) {
            final Class<? extends Sensor> sensor = sensorList.iterator().next();
            final List<Class<? extends Sensor>> sensorVersions = getSensorVersions(sensor, sensorList);

            sensorHelper.addMethod(method_isSensor(sensor, sensorVersions));

            //REMOVE SENSORS VARIANTS FROM LIST
            for (Class<? extends Sensor> sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        sensorHelper.addField(sensorField);
        sensorHelper.addMethod(constructor);

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(SensorTypeHelper.class.getPackage().getName(), sensorHelper.build()).build();
    }

    private static MethodSpec method_isSensor(final Class<? extends Sensor> sensor, final List<Class<? extends Sensor>> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("is" + getBasicSensorName(sensor.getSimpleName()))
                .addModifiers(PUBLIC)
                .returns(boolean.class);


        final String returnLine = "return " + sensorVersions.stream()
                .map(sv -> "sensor.isClassType($T.class)").collect(Collectors.joining(" || "));
        return method.addStatement(returnLine, sensorVersions.toArray()).build();
    }

    private static MethodSpec constructor() {
        return MethodSpec.constructorBuilder()
                .addParameter(Sensor.class, "sensor")
                .addModifiers(PUBLIC).addStatement("this.sensor = sensor")
                .build();
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }

}