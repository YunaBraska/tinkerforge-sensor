package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.SensorList;
import berlin.yuna.tinkerforgesensor.model.SensorListBasic;
import berlin.yuna.tinkerforgesensor.model.sensor.bricklet.Sensor;
import berlin.yuna.tinkerforgesensor.model.type.ValueType;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.toHumanReadable;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorSensorList {

    private static final String SUPER_CLASS_NAME = Sensor.class.getSimpleName();

    public static JavaFile generate(final List<Class<? extends Sensor>> sensorList) {
        StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        Collections.reverse(sensorList);

        //CREATE CLASS
        TypeSpec.Builder sensorListClass = TypeSpec.classBuilder(SensorList.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addTypeVariable(TypeVariableName.get("T", Sensor.class))
                .superclass(ParameterizedTypeName.get(ClassName.get(SensorListBasic.class), TypeVariableName.get("T")))
                .addJavadoc("$N\n", autogenerated);

        //CREATE METHODS
        while (!sensorList.isEmpty()) {
            Class<? extends Sensor> sensor = sensorList.iterator().next();
            List<Class<? extends Sensor>> sensorVersions = getSensorVersions(sensor, sensorList);

            MethodSpec method_getSensorXY = MethodSpec.methodBuilder("get" + getBasicSensorName(sensor.getSimpleName()))
                    .addModifiers(PUBLIC)
                    .returns(Sensor.class).addStatement("return get$N(0)", getBasicSensorName(sensor.getSimpleName())).build();


            sensorListClass.addMethod(method_getSensorXY);

            sensorListClass.addMethod(method_getSensorXYNumber(sensor, sensorVersions));


            //REMOVE SENSORS VARIANTS FROM LIST
            for (Class<? extends Sensor> sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //CREATE ENUM VALUES AND METHODS
        for (ValueType valueType : ValueType.values()) {
            sensorListClass.addMethod(method_getValue(valueType));
        }

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(SensorList.class.getPackage().getName(), sensorListClass.build()).build();
    }

    private static MethodSpec method_getSensorXYNumber(final Class<? extends Sensor> sensor, final List<Class<? extends Sensor>> sensorVersions) {
        MethodSpec.Builder method = MethodSpec.methodBuilder("get" + getBasicSensorName(sensor.getSimpleName()))
                .addModifiers(PUBLIC)
                .returns(Sensor.class)
                .addParameter(int.class, "number");

        StringBuilder sb = new StringBuilder();
        sb.append("return getSensor(number");
        for (Class<? extends Sensor> sensorVersion : sensorVersions) {
            sb.append(", $T.class");
        }
        sb.append(")");

        return method.addStatement(sb.toString(), sensorVersions.toArray()).build();
    }

    private static MethodSpec method_getValue(final ValueType valueType) {
        return MethodSpec.methodBuilder("getValue" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(Long.class)
                .addStatement("$T<$T, $T> result = values($T.$L)", HashMap.class, Sensor.class, Long.class, ValueType.class, valueType.name())
                .addStatement("return result.isEmpty()? 0L : result.values().iterator().next()")
                .build();
    }

    private static List<Class<? extends Sensor>> getSensorVersions(Class<? extends Sensor> sensor, final List<Class<? extends Sensor>> sensorList) {
        String className = sensor.getSimpleName();
        String packageName = sensor.getPackage().getName();
        String name = getBasicSensorName(className);
        List<Class<? extends Sensor>> sensorVersionList = sensorList.stream()
                .filter(sensorClass -> packageName.equals(sensorClass.getPackage().getName()))
                .filter(sensorClass -> sensorClass.getSimpleName().startsWith(name))
                .filter(sensorClass -> sensorClass.getSimpleName().length() < name.length() + 3).sorted(Comparator.comparing(Class::getSimpleName)).collect(Collectors.toList());
        Collections.reverse(sensorVersionList);
        return sensorVersionList;
    }

    private static String getBasicSensorName(final String className) {
        return className.charAt(className.length() - 2) == 'V' ? className.substring(0, className.length() - 2) : className;
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }
}