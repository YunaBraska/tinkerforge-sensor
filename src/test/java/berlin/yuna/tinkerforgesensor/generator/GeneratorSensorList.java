package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.SensorList;
import berlin.yuna.tinkerforgesensor.model.SensorListBasic;
import berlin.yuna.tinkerforgesensor.model.sensor.bricklet.Sensor;
import berlin.yuna.tinkerforgesensor.model.type.ValueType;
import com.squareup.javapoet.*;

import java.util.*;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.toHumanReadable;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorSensorList {

    private static final String SUPER_CLASS_NAME = Sensor.class.getSimpleName();

    public static JavaFile generate(final List<Class<? extends Sensor>> sensorList) {
        StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        Collections.reverse(sensorList);

        //CREATE CLASS
        TypeSpec.Builder sensorListClass = TypeSpec.classBuilder(SensorList.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addTypeVariable(TypeVariableName.get("T", Sensor.class))
                .superclass(ParameterizedTypeName.get(ClassName.get(SensorListBasic.class), TypeVariableName.get("T")))
                .addJavadoc("$N\n", autogenerated);

        //CREATE METHODS
        while (!sensorList.isEmpty()) {
            Class<? extends Sensor> sensor = sensorList.iterator().next();
            String sensorName = sensor.getSimpleName();
            String packageName = sensorList.get(0).getPackage().getName();
            List<Class<? extends Sensor>> sensorVersions = getSensorVersions(sensorList, sensorName, packageName);

            MethodSpec.Builder method_getSensorXY = MethodSpec.methodBuilder("get" + getBasicSensorName(sensorName))
                    .addModifiers(PUBLIC)
                    .returns(Sensor.class);
            sensorListClass.addMethod(generateMethodContent(sensorVersions, method_getSensorXY).build());
            sensorListClass.addMethod(method_getSensorNumber(sensor));
            //REMOVE SENSORS VARIANTS FROM LIST
            for (Class<? extends Sensor> sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //CREATE ENUM VALUES AND METHODS
        for (ValueType valueType : ValueType.values()) {
            sensorListClass.addMethod(method_getValue(valueType));
        }

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(SensorList.class.getPackage().getName(), sensorListClass.build()).build();
    }

    //TODO: version less sensor sensorXYNumber(n)
    private static MethodSpec method_getSensorNumber(final Class<? extends Sensor> sensor) {
        return MethodSpec.methodBuilder("getSensor" + sensor.getSimpleName())
                .addModifiers(PUBLIC)
                .returns(Sensor.class)
                .addParameter(int.class, "number")
                .addStatement("return getSensorNumber($T.class, number)", sensor)
                .build();
    }

    private static MethodSpec method_getValue(final ValueType valueType) {
        return MethodSpec.methodBuilder("getValue" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(Long.class)
                .addStatement("$T<$T, $T> result = values($T.$L)", HashMap.class, Sensor.class, Long.class, ValueType.class, valueType.name())
                .addStatement("return result.isEmpty()? 0L : result.values().iterator().next()")
                .build();
    }

    private static MethodSpec.Builder generateMethodContent(final List<Class<? extends Sensor>> sensorVersions, final MethodSpec.Builder methodBuilder) {
        String superClassNameLow = firstLetterLow(SUPER_CLASS_NAME);
        Iterator<Class<? extends Sensor>> versionIterator = sensorVersions.iterator();

        if (sensorVersions.size() == 1) {
            methodBuilder.addStatement("return first($T.class)", next(versionIterator));
        } else {
            methodBuilder.addStatement("$N $N = first($T.class)", SUPER_CLASS_NAME, superClassNameLow, next(versionIterator));
            while (versionIterator.hasNext()) {
                ClassName className = next(versionIterator);
                if (versionIterator.hasNext()) {
                    methodBuilder.addStatement("$N = $N.isPresent() ? $N : first($T.class)", superClassNameLow, superClassNameLow, superClassNameLow, className);
                } else {
                    methodBuilder.addStatement("return $N.isPresent() ? $N : first($T.class)", superClassNameLow, superClassNameLow, className);
                }
            }
        }
        return methodBuilder;
    }

    private static ClassName next(Iterator<Class<? extends Sensor>> versionIterator) {
        Class<? extends Sensor> next = versionIterator.next();
        return ClassName.get(next.getPackage().getName(), next.getSimpleName());
    }

    private static List<Class<? extends Sensor>> getSensorVersions(final List<Class<? extends Sensor>> sensorList, final String
            className, final String packageName) {
        String name = getBasicSensorName(className);
        List<Class<? extends Sensor>> sensorVersionList = sensorList.stream()
                .filter(sensorClass -> packageName.equals(sensorClass.getPackage().getName()))
                .filter(sensorClass -> sensorClass.getSimpleName().startsWith(name))
                .filter(sensorClass -> sensorClass.getSimpleName().length() < name.length() + 3).sorted(Comparator.comparing(Class::getSimpleName)).collect(Collectors.toList());
        Collections.reverse(sensorVersionList);
        return sensorVersionList;
    }

    private static String getBasicSensorName(final String className) {
        return className.charAt(className.length() - 2) == 'V' ? className.substring(0, className.length() - 2) : className;
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }
}