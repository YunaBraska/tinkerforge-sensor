package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.SensorList;
import berlin.yuna.tinkerforgesensor.model.SensorListBasic;
import berlin.yuna.tinkerforgesensor.model.sensor.bricklet.Sensor;
import berlin.yuna.tinkerforgesensor.model.type.ValueType;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getBasicSensorName;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getSensorVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.toHumanReadable;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorSensorList {

    public static JavaFile generate(final List<Class<? extends Sensor>> sensorList) {
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        Collections.reverse(sensorList);

        //CREATE CLASS
        final TypeSpec.Builder sensorListClass = TypeSpec.classBuilder(SensorList.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addTypeVariable(TypeVariableName.get("T", Sensor.class))
                .superclass(ParameterizedTypeName.get(ClassName.get(SensorListBasic.class), TypeVariableName.get("T")))
                .addJavadoc("$N\n", autogenerated);

        //CREATE METHODS
        while (!sensorList.isEmpty()) {
            final Class<? extends Sensor> sensor = sensorList.iterator().next();
            final List<Class<? extends Sensor>> sensorVersions = getSensorVersions(sensor, sensorList);

            final MethodSpec method_getSensorXY = MethodSpec.methodBuilder("get" + getBasicSensorName(sensor.getSimpleName()))
                    .addModifiers(PUBLIC)
                    .returns(Sensor.class).addStatement("return get$N(0)", getBasicSensorName(sensor.getSimpleName())).build();


            sensorListClass.addMethod(method_getSensorXY);

            sensorListClass.addMethod(method_getSensorXYNumber(sensor, sensorVersions));


            //REMOVE SENSORS VARIANTS FROM LIST
            for (Class<? extends Sensor> sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //CREATE ENUM VALUES AND METHODS
        for (ValueType valueType : ValueType.values()) {
            sensorListClass.addMethod(method_getValue(valueType));
        }

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(SensorList.class.getPackage().getName(), sensorListClass.build()).build();
    }

    private static MethodSpec method_getSensorXYNumber(final Class<? extends Sensor> sensor, final List<Class<? extends Sensor>> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("get" + getBasicSensorName(sensor.getSimpleName()))
                .addModifiers(PUBLIC)
                .returns(Sensor.class)
                .addParameter(int.class, "number", FINAL);

        final StringBuilder sb = new StringBuilder();
        sb.append("return getSensor(number");
        for (Class<? extends Sensor> ignore : sensorVersions) {
            sb.append(", $T.class");
        }
        sb.append(")");

        return method.addStatement(sb.toString(), sensorVersions.toArray()).build();
    }

    private static MethodSpec method_getValue(final ValueType valueType) {
        return MethodSpec.methodBuilder("getValue" + toHumanReadable(valueType, true))
                .addModifiers(PUBLIC)
                .returns(Long.class)
                .addStatement("final $T<$T, $T> result = values($T.$L)", HashMap.class, Sensor.class, Long.class, ValueType.class, valueType.name())
                .addStatement("return result.isEmpty()? 0L : result.values().iterator().next()")
                .build();
    }
}