package berlin.yuna.tinkerforgesensor.generator;


import berlin.yuna.tinkerforgesensor.model.JFile;
import berlin.yuna.tinkerforgesensor.model.SensorRegistry;
import berlin.yuna.tinkerforgesensor.model.sensor.Sensor;
import berlin.yuna.tinkerforgesensor.model.sensor.Sensor.DeviceFactory;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.tinkerforge.Device;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.SEPARATOR;
import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
import static java.util.Arrays.asList;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public class GeneratorSensorRegistry {

    public static JavaFile generate(final List<JFile> sensors) {
        final List<JFile> sensorList = new ArrayList<>(sensors);
        final String deviceLowName = firstLetterLow(Device.class.getSimpleName());
        final TypeName classOfAnyDevice = ParameterizedTypeName.get(ClassName.get(Class.class), subtypeOf(Device.class));
        final TypeName mapIntegerAndDeviceFactory = ParameterizedTypeName.get(ClassName.get(ConcurrentHashMap.class), ClassName.get(Integer.class), ClassName.get(DeviceFactory.class));
        final TypeName mapOfDeviceOfAnyAndSensorFactory = ParameterizedTypeName.get(ClassName.get(ConcurrentHashMap.class), classOfAnyDevice, ClassName.get(Sensor.SensorFactory.class));
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";

        //INIT SENSOR
        final MethodSpec method_initSensor = methodInitSensor(mapOfDeviceOfAnyAndSensorFactory, sensorList);
        final MethodSpec method_initDevice = methodInitDevice(mapIntegerAndDeviceFactory, sensorList);

        //CREATE CLASS
        final TypeSpec.Builder resultClass = TypeSpec.classBuilder(SensorRegistry.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addJavadoc("$N" + SEPARATOR + "Registration of {@link $T} and the Wrapper" + SEPARATOR + "{@link $T}" + SEPARATOR, autogenerated, Device.class, Sensor.class);

        //CALLBACK_PERIOD
        final FieldSpec callbackPeriod = FieldSpec.builder(int.class, "CALLBACK_PERIOD", PUBLIC, STATIC, FINAL).initializer("$L", 64).build();

        //SENSOR MAP
        final FieldSpec sensorMap = FieldSpec.builder(mapOfDeviceOfAnyAndSensorFactory, "sensorMap").addModifiers(PRIVATE, STATIC, FINAL).initializer("$N()", method_initSensor.name).build();
        final MethodSpec method_getAvailableDevices = methodGetAvailableDevices(sensorMap);
        final MethodSpec getSensor = methodGetSensor(deviceLowName, classOfAnyDevice, sensorMap);

        //DEVICE MAP
        final FieldSpec deviceMap = FieldSpec.builder(mapIntegerAndDeviceFactory, "deviceMap").addModifiers(PRIVATE, STATIC, FINAL).initializer("$N()", method_initDevice.name).build();
        final MethodSpec getDevice = method_getDevice(deviceMap);

        resultClass.addFields(asList(callbackPeriod, sensorMap, deviceMap));
        resultClass.addMethods(asList(getSensor, getDevice, method_getAvailableDevices, method_initSensor, method_initDevice));

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(SensorRegistry.class.getPackage().getName(), resultClass.build()).build();
    }

    private static MethodSpec methodGetSensor(final String deviceLowName, final TypeName classOfAnyDevice, final FieldSpec sensorMap) {
        return MethodSpec.methodBuilder("getSensor").addModifiers(PUBLIC, STATIC).returns(Sensor.SensorFactory.class)
                .addParameter(classOfAnyDevice, firstLetterLow(deviceLowName), FINAL)
                .addStatement("return $N.get($N)", sensorMap.name, deviceLowName)
                .build();
    }

    private static MethodSpec method_getDevice(final FieldSpec deviceMap) {
        return MethodSpec.methodBuilder("getDevice").addModifiers(PUBLIC, STATIC).returns(DeviceFactory.class)
                .addParameter(Integer.class, "deviceIdentifier", FINAL)
                .addStatement("return $N.get($N)", deviceMap.name, "deviceIdentifier")
                .build();
    }

    private static MethodSpec methodGetAvailableDevices(final FieldSpec sensorMap) {
        return MethodSpec.methodBuilder("getDeviceAvailableDevices")
                .addModifiers(PUBLIC, STATIC).returns(ParameterizedTypeName.get(List.class, Class.class))
                .addStatement("return new $T<>($N.keySet())", ArrayList.class, sensorMap.name)
                .build();
    }

    private static MethodSpec methodInitSensor(final TypeName mapOfDeviceOfAnyAndSensorFactory, final List<JFile> sensorList) {
        final MethodSpec.Builder initSensor_spec = MethodSpec.methodBuilder("initSensor")
                .addModifiers(PRIVATE, STATIC)
                .returns(mapOfDeviceOfAnyAndSensorFactory)
                .addStatement("final $T<Class<? extends $T>, $T> registry = new $T<>()", ConcurrentHashMap.class, Device.class, Sensor.SensorFactory.class, ConcurrentHashMap.class);
        for (JFile sensor : sensorList) {
            initSensor_spec.addStatement("registry.put($T.class, $T::new)", sensor.getGenericClass(), sensor.getClazz());
        }
        return initSensor_spec.addStatement("return registry").build();
    }

    private static MethodSpec methodInitDevice(final TypeName mapOfDeviceOfAnyAndSensorFactory, final List<JFile> sensorList) {
        final MethodSpec.Builder initSensor_spec = MethodSpec.methodBuilder("initDevice")
                .addModifiers(PRIVATE, STATIC)
                .returns(mapOfDeviceOfAnyAndSensorFactory)
                .addStatement("final $T<$T, $T> registry = new $T<>()", ConcurrentHashMap.class, Integer.class, DeviceFactory.class, ConcurrentHashMap.class);
        for (JFile sensor : sensorList) {
            initSensor_spec.addStatement("registry.put($T.DEVICE_IDENTIFIER, $T::new)", sensor.getGenericClass(), sensor.getGenericClass());
        }
        return initSensor_spec.addStatement("return registry").build();
    }

    private static String firstLetterLow(final String input) {
        return input.substring(0, 1).toLowerCase() + input.substring(1);
    }

}