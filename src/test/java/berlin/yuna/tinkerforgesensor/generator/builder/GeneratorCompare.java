package berlin.yuna.tinkerforgesensor.generator.builder;


import berlin.yuna.tinkerforgesensor.model.builder.Compare;
import berlin.yuna.tinkerforgesensor.model.sensor.bricklet.Sensor;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getBasicSensorName;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getSensorVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.separator;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.DOT_ARRAY;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorCompare {

    public static JavaFile generate(final List<Class<? extends Sensor>> sensors) {
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        final List<Class<? extends Sensor>> sensorList = new ArrayList<>(sensors);

        //CREATE CLASS
        final TypeSpec.Builder resultClass = TypeSpec.classBuilder(Compare.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addJavadoc("$N"  + separator, autogenerated);

        //CREATE CONSTRUCTOR
        resultClass.addField(Sensor.class, "sensor", PRIVATE, FINAL);
        resultClass.addMethod(constructor());

        //CREATE METHODS
        resultClass.addMethod(method_isSensor());
        resultClass.addMethod(method_isClass());

        //GENERATE METHODS
        while (!sensorList.isEmpty()) {
            final Class<? extends Sensor> sensor = sensorList.iterator().next();
            final List<Class<? extends Sensor>> sensorVersions = getSensorVersions(sensor, sensorList);

            resultClass.addMethod(method_isSensorXy(sensor, sensorVersions));

            //REMOVE SENSORS VARIANTS FROM LIST
            for (Class<? extends Sensor> sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(Compare.class.getPackage().getName(), resultClass.build()).build();
    }

    private static MethodSpec method_isSensorXy(final Class<? extends Sensor> sensor, final List<Class<? extends Sensor>> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("is" + getBasicSensorName(sensor.getSimpleName()))
                .addModifiers(PUBLIC)
                .returns(boolean.class);


        final String returnLine = "return " + sensorVersions.stream()
                .map(sv -> "$T.class").collect(Collectors.joining(", ", "is(", ")"));
        return method.addStatement(returnLine, sensorVersions.toArray()).build();
    }

    private static MethodSpec method_isSensor() {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Sensor.class), "sensors" + DOT_ARRAY, FINAL)
                .addCode("for ($T sensor : sensors) {" + separator, Sensor.class)
                .addCode("  if (sensor != null && sensor.uid.equals(this.sensor.uid)) {" + separator)
                .addCode("    return true;" + separator)
                .addCode("  }" + separator)
                .addCode("}" + separator)
                .addCode("return false;" + separator)
                .returns(boolean.class).build();
    }

    private static MethodSpec method_isClass() {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Class.class), "sensorOrDevices" + DOT_ARRAY, FINAL)
                .addCode("for ($T sensorOrDevice : sensorOrDevices) {" + separator, Class.class)
                .addCode("  if (sensor.getClass() == sensorOrDevice || sensor.getType() == sensorOrDevice) {" + separator)
                .addCode("    return true;" + separator)
                .addCode("  }" + separator)
                .addCode("}" + separator)
                .addCode("return false;" + separator)
                .returns(boolean.class).build();
    }

    private static MethodSpec constructor() {
        return MethodSpec.constructorBuilder()
                .addParameter(Sensor.class, "sensor", FINAL)
                .addModifiers(PUBLIC).addStatement("this.sensor = sensor")
                .build();
    }

}