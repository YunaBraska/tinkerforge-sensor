package berlin.yuna.tinkerforgesensor.generator.builder;


import berlin.yuna.tinkerforgesensor.model.JFile;
import berlin.yuna.tinkerforgesensor.model.builder.Compare;
import berlin.yuna.tinkerforgesensor.model.sensor.Sensor;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getClassVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.SEPARATOR;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.DOT_ARRAY;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;

public class GeneratorCompare {

    public static JavaFile generate(final List<JFile> sensors) {
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        final List<JFile> sensorList = new ArrayList<>(sensors);

        //CREATE CLASS
        final TypeSpec.Builder resultClass = TypeSpec.classBuilder(Compare.class.getSimpleName())
                .addModifiers(PUBLIC)
                .addJavadoc("$N" + SEPARATOR, autogenerated);

        //CREATE CONSTRUCTOR
        resultClass.addField(Sensor.class, "sensor", PRIVATE, FINAL);
        resultClass.addMethod(constructor());

        //CREATE METHODS
        resultClass.addMethod(method_isSensor());
        resultClass.addMethod(method_isClass());

        //GENERATE METHODS
        while (!sensorList.isEmpty()) {
            final JFile sensor = sensorList.iterator().next();
            final List<JFile> sensorVersions = getClassVersions(sensor, sensorList);

            resultClass.addMethod(method_isSensorXy(sensor, sensorVersions));

            //REMOVE SENSORS VARIANTS FROM LIST
            for (JFile sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(Compare.class.getPackage().getName(), resultClass.build()).build();
    }

    private static MethodSpec method_isSensorXy(final JFile sensor, final List<JFile> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("is" + sensor.getBasicName())
                .addModifiers(PUBLIC)
                .returns(boolean.class);


        final String returnLine = "return " + sensorVersions.stream()
                .map(sv -> "$T.class").collect(Collectors.joining(", ", "is(", ")"));
        return method.addStatement(returnLine, sensorVersions.stream().map(JFile::getClazz).toArray()).build();
    }

    private static MethodSpec method_isSensor() {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Sensor.class), "sensors" + DOT_ARRAY, FINAL)
                .addCode("for ($T sensor : sensors) {" + SEPARATOR, Sensor.class)
                .addCode("  if (sensor != null && sensor.uid.equals(this.sensor.uid)) {" + SEPARATOR)
                .addCode("    return true;" + SEPARATOR)
                .addCode("  }" + SEPARATOR)
                .addCode("}" + SEPARATOR)
                .addCode("return false;" + SEPARATOR)
                .returns(boolean.class).build();
    }

    private static MethodSpec method_isClass() {
        return MethodSpec.methodBuilder("is")
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Class.class), "sensorOrDevices" + DOT_ARRAY, FINAL)
                .addCode("for ($T sensorOrDevice : sensorOrDevices) {" + SEPARATOR, Class.class)
                .addCode("  if (sensor.getClass() == sensorOrDevice || sensor.getType() == sensorOrDevice) {" + SEPARATOR)
                .addCode("    return true;" + SEPARATOR)
                .addCode("  }" + SEPARATOR)
                .addCode("}" + SEPARATOR)
                .addCode("return false;" + SEPARATOR)
                .returns(boolean.class).build();
    }

    private static MethodSpec constructor() {
        return MethodSpec.constructorBuilder()
                .addParameter(Sensor.class, "sensor", FINAL)
                .addModifiers(PUBLIC).addStatement("this.sensor = sensor")
                .build();
    }

}