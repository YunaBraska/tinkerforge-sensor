package berlin.yuna.tinkerforgesensor.generator.builder;


import berlin.yuna.tinkerforgesensor.model.JFile;
import berlin.yuna.tinkerforgesensor.model.builder.Sensors;
import berlin.yuna.tinkerforgesensor.model.exception.NetworkConnectionException;
import berlin.yuna.tinkerforgesensor.model.sensor.Default;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplayLcd128x64;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplayLcd20x4;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplaySegment;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplaySegmentV2;
import berlin.yuna.tinkerforgesensor.model.sensor.Sensor;
import berlin.yuna.tinkerforgesensor.model.sensor.SoundIntensity;
import berlin.yuna.tinkerforgesensor.model.sensor.SoundPressure;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Matcher;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.SEPARATOR;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.firstLetterLow;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getClassVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.DOT_ARRAY;
import static berlin.yuna.tinkerforgesensor.model.JFile.PATTERN_FILE_VERSIONS;
import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
import static java.util.Arrays.asList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.SYNCHRONIZED;

public class GeneratorSensors {

    public static List<JavaFile> generate(final List<JFile> sensors) {
        final Class<Sensors> baseClass = Sensors.class;
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + requireNonNull(trace.getFileName()).replace(".java", "") + ":" + trace.getMethodName() + "]";
        final List<JFile> sensorList = new ArrayList<>(sensors);
        final HashMap<String, TypeSpec.Builder> resultClasses = new HashMap<>();

        //TYPE DEFINITIONS
        final ParameterizedTypeName type_ListOfSensor = ParameterizedTypeName.get(List.class, Sensor.class);
        final ClassName type_ClassOfGenerics = ClassName.get(Class.class);


        //TODO: refactor sensor versions
        sensorList.forEach(sensor -> {
            if (!"default".equals(sensor.getBasicName().toLowerCase())) {
                final String sensorBaseName;
                final String sensorVersion;
                final Matcher match = PATTERN_FILE_VERSIONS.matcher(sensor.getSimpleName());
                if (match.find()) {
                    sensorBaseName = match.group("name");
                    sensorVersion = match.group("version");
                } else {
                    sensorBaseName = sensor.getSimpleName();
                    sensorVersion = "V1";
                }

                final TypeSpec.Builder resultClass = resultClasses.computeIfAbsent(sensorVersion, v -> prepareResultClass(baseClass, autogenerated, sensorVersion));

                resultClass.addMethod(
                        MethodSpec.methodBuilder(firstLetterLow(sensorBaseName))
                                .addModifiers(PUBLIC)
                                .returns(sensor.getClazz())
                                .addStatement("return $N(0)", firstLetterLow(sensorBaseName))
                                .build()
                );

                resultClass.addMethod(
                        MethodSpec.methodBuilder(firstLetterLow(sensorBaseName))
                                .addModifiers(PUBLIC)
                                .addParameter(int.class, "number", FINAL)
                                .returns(sensor.getClazz())
                                .addStatement("return ($T) getSensor(number, $T.class)", sensor.getClazz(), sensor.getClazz())
                                .build()
                );
            }
        });

        //GENERATE METHODS
        Collections.reverse(sensorList);
        final TypeSpec.Builder noVersionClass = resultClasses.computeIfAbsent("", v -> prepareResultClass(baseClass, autogenerated, ""));
        while (!sensorList.isEmpty()) {
            final JFile sensor = sensorList.iterator().next();
            final List<JFile> sensorVersions = getClassVersions(sensor, sensorList);
            final String methodName = firstLetterLow(sensor.getBasicName());

            if (!"default".equals(methodName)) {
                noVersionClass.addMethods(addSensorShortcuts(type_ListOfSensor, sensor.getBasicName(), sensorVersions.stream().map(JFile::getClazz).collect(toList())));
            }

            //REMOVE SENSORS VARIANTS FROM LIST
            for (JFile sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //ADDITIONAL SENSOR SHORTCUTS
        noVersionClass.addMethods(addSensorShortcuts(type_ListOfSensor, "Display", asList(DisplayLcd128x64.class, DisplayLcd20x4.class, DisplaySegmentV2.class, DisplaySegment.class)));
        noVersionClass.addMethods(addSensorShortcuts(type_ListOfSensor, "Sound", asList(SoundPressure.class, SoundIntensity.class)));

        resultClasses.values().forEach(resultClass -> {
            //CREATE METHODS
            final MethodSpec method_getDefaultSensor = method_getDefaultSensor(type_ClassOfGenerics);
            resultClass.addMethod(method_getSensor(type_ListOfSensor, type_ClassOfGenerics));
            resultClass.addMethod(method_getSensorNumber(type_ListOfSensor, type_ClassOfGenerics, method_getDefaultSensor));
            resultClass.addMethod(method_getDefaultSensor);
        });

        //Path sourceFile = getSourceFile(packageName, className);
        return resultClasses.values().stream().map(builderClass ->
                JavaFile.builder(baseClass.getPackage().getName(), builderClass.build()).build()
        ).collect(toList());
    }

    public static TypeSpec.Builder prepareResultClass(final Class<Sensors> generateClass, final String autogenerated, final String sensorVersion) {
        //CREATE CLASS
        final TypeSpec.Builder builder = TypeSpec.classBuilder(generateClass.getSimpleName() + sensorVersion)
                .addModifiers(PUBLIC)
                .superclass(ParameterizedTypeName.get(ClassName.get(CopyOnWriteArrayList.class), TypeVariableName.get(Sensor.class)))
                .addJavadoc("$N" + SEPARATOR, autogenerated);

        //CREATE CONSTRUCTOR
        builder.addMethod(constructor_empty());
        builder.addMethod(constructor_collection());
        builder.addMethod(constructor_array());
        return builder;
    }

    private static List<MethodSpec> addSensorShortcuts(final ParameterizedTypeName type_ListOfSensor, final String sensorName, final List<Class> sensorVersions) {
        final String sensorNameLow = firstLetterLow(sensorName);
        final MethodSpec sensorXY = method_getSensorXY(sensorNameLow);
        final MethodSpec getSensorXYNumber = method_getSensorXYNumber(sensorNameLow, sensorVersions);
        final MethodSpec getSensorListXY = method_getSensorListXY(type_ListOfSensor, sensorName, sensorVersions);
        return asList(sensorXY, getSensorXYNumber, getSensorListXY);
    }

    private static MethodSpec method_getDefaultSensor(final ClassName type_ClassOfGenerics) {
        final String parameterName = "sensorClass";
        return MethodSpec.methodBuilder("getDefaultSensor")
                .addModifiers(PRIVATE)
                .addParameter(type_ClassOfGenerics, parameterName, FINAL)
                .addCode(
                        "try {" + SEPARATOR + "  return new $T($N);" + SEPARATOR + "} catch ($T e) {" + SEPARATOR + "  throw new $T(\"Default device should not run into an exception\", e);" + SEPARATOR + "}" + SEPARATOR,
                        Default.class, parameterName, TypeName.get(NetworkConnectionException.class), TypeName.get(RuntimeException.class)
                )
                .returns(Sensor.class)
                .build();
    }

    private static MethodSpec method_getSensor(final ParameterizedTypeName type_ListOfSensor, final ClassName type_ClassOfGenerics) {
        final String parameterName = "sensorClasses";
        return MethodSpec.methodBuilder("get" + Sensor.class.getSimpleName())
                .addModifiers(PRIVATE, SYNCHRONIZED)
                .addParameter(ArrayTypeName.of(type_ClassOfGenerics), parameterName + DOT_ARRAY, FINAL)
                .returns(type_ListOfSensor)
                .addStatement("return stream().filter(sensor -> sensor.compare().is($N)).sorted($N($T::port)).collect($N)", parameterName, "java.util.Comparator.comparingInt", Sensor.class, "java.util.stream.Collectors.toList()")
                .build();
    }

    private static MethodSpec method_getSensorNumber(final ParameterizedTypeName type_ListOfSensor, final ClassName type_ClassOfGenerics, final MethodSpec method_getDefaultSensor) {
        final String parameterName = "sensorClasses";
        final String parameterNumber = "number";
        return MethodSpec.methodBuilder("get" + Sensor.class.getSimpleName())
                .addModifiers(PRIVATE, SYNCHRONIZED)
                //regex [] ... \(final.*\[].*\).*\{
                .addParameter(int.class, parameterNumber, FINAL)
                .addParameter(ArrayTypeName.of(type_ClassOfGenerics), parameterName + DOT_ARRAY, FINAL)
                .returns(Sensor.class)
                .addStatement("final $T sensors = get$T($N)", type_ListOfSensor, Sensor.class, parameterName)
                .addStatement("return $N < sensors.size() ? sensors.get($N) : $N($N[0])", parameterNumber, parameterNumber, method_getDefaultSensor.name, parameterName)
                .build();
    }

    private static MethodSpec constructor_empty() {
        return MethodSpec.constructorBuilder().addModifiers(PUBLIC).build();
    }

    private static MethodSpec constructor_collection() {
        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addParameter(ParameterizedTypeName.get(ClassName.get(Collection.class), subtypeOf(Sensor.class)), "collection", FINAL)
                .addStatement("super(collection)")
                .build();
    }

    private static MethodSpec constructor_array() {
        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Sensor.class), "toCopyIn", FINAL)
                .addStatement("super(toCopyIn)")
                .build();
    }

    private static MethodSpec method_getSensorXY(final String methodName) {
        return MethodSpec.methodBuilder(methodName)
                .addModifiers(PUBLIC)
                .returns(Sensor.class).addStatement("return $N(0)", methodName).build();
    }

    private static MethodSpec method_getSensorListXY(final ParameterizedTypeName type_ListOfSensor, final String sensorName, final List<Class> sensorVersions) {
        final String returnLine = "return get" + Sensor.class.getSimpleName() + sensorVersions.stream()
                .map(sv -> "$T.class").collect(Collectors.joining(", ", "(", ")"));
        return MethodSpec.methodBuilder("get" + sensorName + "List")
                .addModifiers(PUBLIC)
                .returns(type_ListOfSensor)
                .addStatement(returnLine, sensorVersions.toArray())
                .build();
    }


    private static MethodSpec method_getSensorXYNumber(final String methodName, final List<Class> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(PUBLIC)
                .returns(Sensor.class)
                .addParameter(int.class, "number", FINAL);

        final String returnLine = "return getSensor" + sensorVersions.stream()
                .map(sv -> "$T.class").collect(Collectors.joining(", ", "(number, ", ")"));
        return method.addStatement(returnLine, sensorVersions.toArray()).build();
    }
}