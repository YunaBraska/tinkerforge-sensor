package berlin.yuna.tinkerforgesensor.generator.builder;


import berlin.yuna.tinkerforgesensor.model.JFile;
import berlin.yuna.tinkerforgesensor.model.builder.Sensors;
import berlin.yuna.tinkerforgesensor.model.exception.NetworkConnectionException;
import berlin.yuna.tinkerforgesensor.model.sensor.Default;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplayLcd20x4;
import berlin.yuna.tinkerforgesensor.model.sensor.DisplaySegment;
import berlin.yuna.tinkerforgesensor.model.sensor.Sensor;
import berlin.yuna.tinkerforgesensor.model.sensor.SoundIntensity;
import berlin.yuna.tinkerforgesensor.model.sensor.SoundPressure;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.firstLetterLow;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.getClassVersions;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorHelper.SEPARATOR;
import static berlin.yuna.tinkerforgesensor.generator.GeneratorTest.DOT_ARRAY;
import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toList;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.SYNCHRONIZED;

public class GeneratorSensors {

    public static JavaFile generate(final List<JFile> sensors) {
        final Class<Sensors> generateClass = Sensors.class;
        final StackTraceElement trace = Thread.currentThread().getStackTrace()[1];
        final String autogenerated = "Autogenerated with [" + trace.getFileName().replace(".java", "") + ":" + trace.getMethodName() + "]";
        final List<JFile> sensorList = new ArrayList<>(sensors);
        Collections.reverse(sensorList);

        //TYPE DEFINITIONS
        final ParameterizedTypeName type_ListOfSensor = ParameterizedTypeName.get(List.class, Sensor.class);
        final ClassName type_ClassOfGenerics = ClassName.get(Class.class);

        //CREATE CLASS
        final TypeSpec.Builder resultClass = TypeSpec.classBuilder(generateClass.getSimpleName())
                .addModifiers(PUBLIC)
                .superclass(ParameterizedTypeName.get(ClassName.get(CopyOnWriteArrayList.class), TypeVariableName.get(Sensor.class)))
                .addJavadoc("$N" + SEPARATOR, autogenerated);

        //CREATE CONSTRUCTOR
        resultClass.addMethod(constructor_empty());
        resultClass.addMethod(constructor_collection());
        resultClass.addMethod(constructor_array());

        //GENERATE METHODS
        while (!sensorList.isEmpty()) {
            final JFile sensor = sensorList.iterator().next();
            final List<JFile> sensorVersions = getClassVersions(sensor, sensorList);
            final String methodName = firstLetterLow(sensor.getBasicName());

            if (!"default".equals(methodName)) {
                resultClass.addMethod(method_getSensorXY(methodName));
                resultClass.addMethod(method_getSensorXYNumber(methodName, sensorVersions.stream().map(JFile::getClazz).collect(toList())));
            }

            //REMOVE SENSORS VARIANTS FROM LIST
            for (JFile sensorVersion : sensorVersions) {
                sensorList.remove(sensorVersion);
            }
        }

        //ADDITIONAL SENSOR SHORTCUTS
        //FIXME: add loop for sensor number?
        resultClass.addMethod(method_getSensorXY("display"));
        resultClass.addMethod(method_getSensorXYNumber("display", asList(DisplayLcd20x4.class, DisplaySegment.class)));
        resultClass.addMethod(method_getSensorXY("sound"));
        resultClass.addMethod(method_getSensorXYNumber("sound", asList(SoundPressure.class, SoundIntensity.class)));

        //CREATE METHODS
        final MethodSpec method_getDefaultSensor = method_getDefaultSensor(type_ListOfSensor, type_ClassOfGenerics);
        resultClass.addMethod(method_getSensor(type_ListOfSensor, type_ClassOfGenerics));
        resultClass.addMethod(method_getSensorNumber(type_ListOfSensor, type_ClassOfGenerics, method_getDefaultSensor));
        resultClass.addMethod(method_getDefaultSensor);

        //Path sourceFile = getSourceFile(packageName, className);
        return JavaFile.builder(generateClass.getPackage().getName(), resultClass.build()).build();
    }

    private static MethodSpec method_getDefaultSensor(final ParameterizedTypeName type_ListOfSensor, final ClassName type_ClassOfGenerics) {
        final String parameterName = "sensorClass";
        return MethodSpec.methodBuilder("getDefaultSensor")
                .addModifiers(PRIVATE)
                .addParameter(type_ClassOfGenerics, parameterName, FINAL)
                .addCode(
                        "try {" + SEPARATOR + "  return new $T($N);" + SEPARATOR + "} catch ($T e) {" + SEPARATOR + "  throw new $T(\"Default device should not run into an exception\", e);" + SEPARATOR + "}" + SEPARATOR,
                        Default.class, parameterName, TypeName.get(NetworkConnectionException.class), TypeName.get(RuntimeException.class)
                )
                .returns(Sensor.class)
                .build();
    }

    private static MethodSpec method_getSensor(final ParameterizedTypeName type_ListOfSensor, final ClassName type_ClassOfGenerics) {
        final String parameterName = "sensorClasses";
        return MethodSpec.methodBuilder("get" + Sensor.class.getSimpleName())
                .addModifiers(PRIVATE, SYNCHRONIZED)
                .addParameter(ArrayTypeName.of(type_ClassOfGenerics), parameterName + DOT_ARRAY, FINAL)
                .returns(type_ListOfSensor)
                .addStatement("return stream().filter(sensor -> sensor.compare().is($N)).sorted($N($T::port)).collect($N)", parameterName, "java.util.Comparator.comparingInt", Sensor.class, "java.util.stream.Collectors.toList()")
                .build();
    }

    private static MethodSpec method_getSensorNumber(final ParameterizedTypeName type_ListOfSensor, final ClassName type_ClassOfGenerics, final MethodSpec method_getDefaultSensor) {
        final String parameterName = "sensorClasses";
        final String parameterNumber = "number";
        return MethodSpec.methodBuilder("get" + Sensor.class.getSimpleName())
                .addModifiers(PRIVATE, SYNCHRONIZED)
                //regex [] ... \(final.*\[].*\).*\{
                .addParameter(int.class, parameterNumber, FINAL)
                .addParameter(ArrayTypeName.of(type_ClassOfGenerics), parameterName + DOT_ARRAY, FINAL)
                .returns(Sensor.class)
                .addStatement("final $T sensors = get$T($N)", type_ListOfSensor, Sensor.class, parameterName)
                .addStatement("return sensors.size() > $N ? sensors.get($N) : $N($N[0])", parameterNumber, parameterNumber, method_getDefaultSensor.name, parameterName)
                .build();
    }

    private static MethodSpec constructor_empty() {
        return MethodSpec.constructorBuilder().addModifiers(PUBLIC).build();
    }

    private static MethodSpec constructor_collection() {
        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addParameter(ParameterizedTypeName.get(ClassName.get(Collection.class), subtypeOf(Sensor.class)), "collection", FINAL)
                .addStatement("super(collection)")
                .build();
    }

    private static MethodSpec constructor_array() {
        return MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addParameter(ArrayTypeName.of(Sensor.class), "toCopyIn", FINAL)
                .addStatement("super(toCopyIn)")
                .build();
    }

//    private static MethodSpec constructor_sensors(final ParameterizedTypeName type_SensorList, final String type_SensorListName) {
//        return MethodSpec.constructorBuilder()
//                .addModifiers(PUBLIC)
//                .addParameter(type_SensorList, type_SensorListName, FINAL)
//                .addStatement("this.$N = $N", type_SensorListName, type_SensorListName)
//                .build();
//    }

    private static MethodSpec method_getSensorXY(final String methodName) {
        return MethodSpec.methodBuilder(methodName)
                .addModifiers(PUBLIC)
                .returns(Sensor.class).addStatement("return $N(0)", methodName).build();
    }

    private static MethodSpec method_getSensorXYNumber(final String methodName, final List<Class> sensorVersions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(PUBLIC)
                .returns(Sensor.class)
                .addParameter(int.class, "number", FINAL);

        final String returnLine = "return getSensor" + sensorVersions.stream()
                .map(sv -> "$T.class").collect(Collectors.joining(", ", "(number, ", ")"));
        return method.addStatement(returnLine, sensorVersions.toArray()).build();
    }
}